#define N 4
#define T 1
#define c(i,j) _c[(i)*(N+T) + (j)]

#define done (outputs[0] != 2 && outputs[1] != 2 && outputs[2] != 2 && outputs[3] != 2)

ltl aggreement { [] (done -> outputs[0] == outputs[1] && outputs[1] == outputs[2] && outputs[2] == outputs[3]) }
ltl validity { true }
ltl termination { true }

// c(i,j) is to send messages from i to j
chan _c[(N+T)*(N+T)] = [1] of {bit};
bit inputs[N+T];
bit outputs[N+T];

proctype reliable(int id) {
  bit v = inputs[id-1];
  bit ithMajority;
  byte zeros = 0; // number of zeros received
  byte i;
  printf("[%d] starting with value = %d\n", id, v)

  byte round = 1;
  do
  :: round > T + 1 -> break
  :: round <= T + 1 ->
      printf("[%d] on round %d\n", id, round);

      // 1

      // 1.1 send its value to every other process
      i = 0;
      do
      :: i < N+T -> c(id-1,i) ! v; i++;
      :: i == N+T -> break;
      od;

      // 1.2 count received values
      printf("[%d] counting received values\n", id);
      i = 0;
      do
      :: i < N+T -> if
                    :: c(i,id-1) ? 0 -> zeros++
                    :: c(i,id-1) ? 1 -> skip
                    fi;
                    i++
      :: i == N+T -> break;
      od;
      printf("[%d] got %d zeros and %d ones\n", id, zeros, N+T-zeros);

      // Part 2

      // 2.1 Node round send majority value it received
      i = 0;
      do
      :: i < N+T -> if
                    :: id == round && (zeros > (N+T) - zeros)   -> c(id-1,i) ! 0;
                    :: id == round && (zeros <= (N+T) - zeros)  -> c(id-1,i) ! 1;
                    :: else -> skip
                    fi;
                    i++
      :: i == N+T -> break;
      od;
      printf("[%d] Node %d should have sent his majority value to everyone\n", id, round);

      // 2.2 Every node reads the sent value
      c(round-1,id-1) ? ithMajority;

      printf("[%d] The value %d sent was %d\n", id, round, ithMajority);

      // 2.3 If it found N with same value, then update v to that value else use ithMajority
      if
      :: zeros >= N -> v = 0
      :: (N+T)-zeros >= N -> v = 1
      :: else -> v = ithMajority;
      fi;


      round++
  od;

  printf("[%d] My value is %d\n", id, v);
  outputs[id-1] = v;
}

proctype faulty(int id) {
  byte round = 1;
  byte i;
  do
  :: round > T + 1 -> break
  :: round <= T + 1 ->
      printf("[%d] on round %d\n", id, round);

      // 1

      // 1.1 send some value to every other process
      i = 0;
      do
      :: i < N+T ->
        if
        :: true -> c(id-1,i) ! 0
        :: true -> c(id-1,i) ! 1
        fi;
        i++
      :: i == N+T -> break;
      od;

      // 1.2 read values and ignore
      printf("[%d] counting received values\n", id);
      i = 0;
      do
      :: i < N+T -> if
                    :: c(i,id-1) ? 0 -> skip
                    :: c(i,id-1) ? 1 -> skip
                    fi;
                    i++
      :: i == N+T -> break;
      od;

      // Part 2

      // 2.1 If round node send any value
      i = 0;
      do
      :: i < N+T -> if
                    :: id == round -> c(id-1,i) ! 0;
                    :: id == round -> c(id-1,i) ! 1;
                    :: else -> skip
                    fi;
                    i++
      :: i == N+T -> break;
      od;

      // 2.2 Read the value and ignore
      if
      :: c(round-1,id-1) ? 0 -> skip;
      :: c(round-1,id-1) ? 1 -> skip;
      fi;

      // 2.3 Nop

      round++
  od;

}

init {
  byte i;

  // Decide inputs for everyone
  i = 0;
  do
  :: i < N ->  if
                :: true -> inputs[i] = 0; printf("[%d] My input is 0\n", i)
                :: true -> inputs[i] = 1; printf("[%d] My input is 1\n", i)
                fi;
                outputs[i] = 2; // some invalid output for termination
                i++
  :: else -> break;
  od

  // Start processes
  i = 1;
  do
  :: i <= N -> run reliable(i); i++
  :: i > N && i <= N+T -> run faulty(i); i++
  :: else -> break;
  od
}
