\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}

\usepackage{graphicx}
\graphicspath{ {./assets/} }

\usepackage{algpseudocode}
\usepackage{algorithm}

\usepackage{tikz}

\newcommand{\wip}{\textbf{(WIP) }}
\newcommand{\tba}{\textbf{(TBA) }}

\newcommand{\blah}{\textbf{blah blah blah}}

\newcommand{\dsa}[1]{\textbf{[DSA: #1]}}

\begin{document}

\title{Project 1 - Report}
\author{
  Diogo Antunes\\
  99210
  \and
  Javier María\\
  99240
  \and
  Tomás Silva\\
  98973
}

\maketitle

\section*{\tba Exercise 1}

\section*{\wip Exercise 2}

% Instructions:
%   - Should include the encoding of the nonogram problem as a SAT problem
% Structure:
% - Two encodings were implemented
% - High-level overview of the encodings
%     - they share some of the structure (of encoding line by line)
%       - explain how this works
%       - In the following sections, we'll only talk about this simplified problem
%     - we have a brute force one that is easier to believe the correctness of but that (has complexity X)
%     - we have a more efficient one that is more complex but also uses less variables (has complexity Y)
%     - from the debugging standpoint, having both implementations proved useful because we were able to use one
% of the implementations to debug the other.
% - ``Brute-force'' approach
%   - One way is to consider all possible combinations
% - Polynomial approach
%   - Intuitively, a brute-force approach doesn't sound right
% - Experimental evaluation
%   - To understand what actually was better, we ran some benchmarks
%   - Show benchmarks, and comment on growth of brute-force approach

Two different encodings for the nonogram problem where implemented and tested.
Both encodings follow the same structure -- encoding the entire problem is reduced to encoding a single line with restrictions.
The encoding of the entire problem is just the and of the encodings of all rows and columns.
Let a line be a list of naturals, which denote the gaps that should exist in the line -- $l = [g_j, ..., g_{j'}]$.
A puzzle is a tuple $\langle H, V\rangle$, where both $H$ and $V$ a list of lines.
The propositional formula that is the encoding of a line $l = [g_j, ..., g_{j'}]$ of size $s$ will be denoted $E(l, s)$.
The two approaches will differ precisely on how $E$ is defined.
The encoding of the entire puzzle is

\begin{center}
  $\bigwedge\limits_{l \in H} E(l, |V|) \wedge \bigwedge\limits_{l \in V} E(l, |H|)$
\end{center}

Both approaches will be a variable per cell in the grid (but one of them will have more variables). The variable for cell at row $i$ and column $j$ will be denoted $x_i_j$.
At a high-level the first encoding uses a ``brute-force'' approach to solving the problem, by considering all possible placements of black regions in a given line.
The second approach tries to avoid this by encoding directly the dependencies between black regions and the rules of the game.
Having both approaches proved useful -- the brute-force one was easy to reason about and was used to debug the second approach.
In the following sub-sections, we will look in detail at how each encoding is made.

\subsection*{``Brute-force'' approach}

As hinted at before, the first and simpler approach to encoding the constraints for a single line is to consider all possible placements of segments of the specified sizes on the line.
For instance, if $l = [1, 2]$ for a line of size 5, the possible configurations are the following:

\begin{center}
\begin{tikzpicture}
    % X _ X X _
    \foreach \x in {1,2,...,5} {
        \ifnum\x=1 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=3 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=4 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else \draw (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \fi\fi\fi
    }

    % X _ _ X X
    \begin{scope}[shift={(3.5, 0)}]
    \foreach \x in {1,2,...,5} {
        \ifnum\x=1 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=4 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=5 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else \draw (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \fi\fi\fi
    }
    \end{scope}

    % _ X _ X X
    \begin{scope}[shift={(7, 0)}]
    \foreach \x in {1,2,...,5} {
        \ifnum\x=2 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=4 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=5 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else \draw (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \fi\fi\fi
    }
    \end{scope}
\end{tikzpicture}
\end{center}

\noindent Before defining the function, we need to define the minimum and maximum start positions for a given gap.

\noindent Given the constraints of the problem, a given gap cannot start at any position in the line.
To avoid considering positions which are impossible regardless of the other constraints that might exist, a minimum and maximum start positions are defined.
The miminum start position for gap $gaps_i$ is defined as $minStart(gaps_i) = \sum_{j = 0}^{i-1}(gaps_{j}+ 1)$. Similarly, the maximum start position for a gap $i$ is $maxStart(gaps_i) = size - g - \sum_{j=i+1}^{size}(gaps_{j} + 1)$.

In general, the list of all possible starts is given by the following function:

\begin{algorithm}
\caption{Function to compute all possible start configurations}\label{alg:allPossible}
\begin{algorithmic}
\Function{AllPossible}{$gaps$, $size$}
  \If{len($gaps$) = 1}
    \State \Return $[ [i]: 0 \le i \le size - gaps_0]$
  \Else
    \State $all = []$
    \For{$i = 0$ to $size - gaps_0$}
      \State $o = start + g + 1$ \Comment{Offset of remaining starts}
      \ForAll{$pos \in AllPossible(gaps[1..], size - o)$}
          \State $all.append([i] + [p + o: p \in pos])$
      \EndFor
    \EndFor
    \State \Return $all$
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

As can be seen, a start configuration is a list of integers that mark where each gap should start.
Given a configuration and the list of gaps, the set of filled positions is $filled(starts, gaps) = \{j\ |\ \exists i: starts_i \le j \le starts_i + gaps_i\}$.

A single start configuration can be encoded as follows:

\begin{center}
  $E(starts, gaps) = \bigwedge\limits_{i \in filled(starts, gaps)}x_i \wedge \bigwedge\limits_{i \notin filled(starts, gaps)} \neg x_i$
\end{center}

\noindent Given the list of all possible starts, the encoding is quite straightforward:

\begin{center}
  $E(l, s) = \bigvee_{starts \in AllPossible(l, s)} E(starts, l)$
\end{center}

\noindent As can be seen, the complexity of this approach is rather bad. As the number of gaps grows, the number of possible combinations is exponential. In particular, if there are $k$ gaps in a line of size $s$, the number of combinations is $\mathcal{O}(s^k)$ possibilities.\footnote{This is a bit of an overestimation, because we only place gaps between the minimum and maximum positions}

\subsection*{Polynomial approach}

This approach attempts to encode not what are the possible combinations that result from the restrictions of the puzzle but the actual rules and restrictions of the nonogram game.
For this, we require an extra set of variables - $c_i_j$ (note that when solving the entire puzzle, conditions for different lines are distinct and so must be given distinct names).
For a given line, $c_i_j$ is intended to mean the gap $i$ was already placed when one gets to position $j$ (when considered from left to right). An ``ghost'' position at the end is considered for convinience (i.e. $c_i_{j}$ exists for $j = size$ as well).
For instance, consider the following example.

\begin{center}
\begin{tikzpicture}
    % X _ X X _
    \foreach \x in {1,2,...,5} {
        \ifnum\x=1 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=3 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else\ifnum\x=4 \filldraw[fill=black] (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \else \draw (\x*0.5, 0) rectangle (\x*0.5+0.5, -0.5);
        \fi\fi\fi
    }
\end{tikzpicture}
\end{center}

\noindent The condition variables will take the following values

\begin{align*}
c_0_0 &= F & c_0_1 &= T & c_0_2 &= T & c_0_3 &= T & c_0_4 &= T & c_0_5 &= T \\
c_1_0 &= F & c_1_1 &= F & c_1_2 &= F & c_1_3 &= F & c_1_4 &= T & c_1_5 &= T
\end{align*}

\noindent Having these extra variables will allow us to encode all the requirements we need. Unlike the previous approach we need to encode several things

\begin{enumerate}
  \item If a gap starts at $i$, then blah. This translates into the following conditions.
  \begin{center}
    $a = b$
  \end{center}

  \item The completion of a gap should propagate to the right
  \begin{center}
    $a = b$
  \end{center}

  \item A gap at a position can only be complete if the appropriate cells where painted black or if the gap was completed before
  \begin{center}
    $a = b$
  \end{center}

  \item Gaps must be completed in order, i.e. there's a cooldown.
  \begin{center}
    $a = b$
  \end{center}

  \item At the start nothing is completed.
  \begin{center}
    $a = b$
  \end{center}

  \item At the end everything should be completed.

  \begin{center}
    $a = b$
  \end{center}
\end{enumerate}

As can be seen, at no point all possible combinations are considered. For that reason, at most a polynomial amount of restrictions are added.

\subsection*{Evaluation}

In this section we compare the two approaches described previously.
For that a puzzle generator was implemented. The puzzle size was set to be the sum of the number of rows and columns. For each puzzle size, a puzzle is generated and then both approaches are used to solve it -- both the initialization time and the SAT solving time are measured. This is repeated 100 times. The results can be seen in Figure~\ref{fig:bench}.

\begin{figure}[h]
  \includegraphics[scale=0.5]{bench.png}
  \centering
  \caption{Execution time for both algorithms proposed}
  \label{fig:bench}
\end{figure}

As can be seen, the polynomial approach is slower for small puzzles, but as soon as the puzzle size reaches 25 it becomes the faster approach.

Additionally, the percentage of time was analysed -- the results are in Figure~\ref{fig:util}

As expected, the initialization time dominates the solving time, especially for smaller problems.

\begin{figure}[h]
  \includegraphics[scale=0.5]{util.png}
  \centering
  \caption{Percentage of time spent in SAT solver}
  \label{fig:bench}
\end{figure}

% TODO: say more stuff

% \listoffigures

\end{document}
